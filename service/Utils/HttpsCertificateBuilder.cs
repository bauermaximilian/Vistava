// SPDX-License-Identifier: GPL-3.0-or-later

using System.Net;
using System.Net.NetworkInformation;
using System.Net.Sockets;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;
using Vistava.Service.Common;

namespace Vistava.Service.Utils;

public class HttpsCertificateBuilder
{
	/// <summary>
	/// Gets or sets the common name of the certificate built with this instance, which will
	/// be shown to the user when displaying the certificate information.
	/// Shouldn't contain IP addresses or server/host names, which should be added to
	/// <see cref="AlternativeIpNames"/> or <see cref="AlternativeDnsNames"/>.
	/// </summary>
	public required string CommonName { get; set; }

	/// <summary>
	/// Gets or sets the date after the certificate built with this instance will be valid.
	/// </summary>
	public required DateTime ValidNotBefore { get; set; }

	/// <summary>
	/// Gets or sets the date until the certificate built with this instance will be valid.
	/// </summary>
	public required DateTime ValidNotAfter { get; set; }

	/// <summary>
	/// Gets or sets the hash algorithm name of the certificate built with this instance.
	/// By default, <see cref="HashAlgorithmName.SHA256"/> is used.
	/// </summary>
	public HashAlgorithmName HashAlgorithmName { get; set; } = HashAlgorithmName.SHA256;

	/// <summary>
	/// Gets or sets the key usage flags of the certificate built with this instance.
	/// By default, <see cref="X509KeyUsageFlags.DigitalSignature"/>,
	/// <see cref="X509KeyUsageFlags.KeyEncipherment"/> and 
	/// <see cref="X509KeyUsageFlags.NonRepudiation"/> is used.
	/// </summary>
	public X509KeyUsageFlags KeyUsageFlags { get; set; } =
		X509KeyUsageFlags.DigitalSignature | X509KeyUsageFlags.KeyEncipherment | 
		X509KeyUsageFlags.NonRepudiation;

	/// <summary>
	/// Gets or sets a collection of DNS names that hosts are allowed to have when using
	/// the certificate generated by this instance.
	/// </summary>
	public ICollection<string> AlternativeDnsNames { get; set; } = new HashSet<string>();

	/// <summary>
	/// Gets or sets a collection of IP addresses that hosts are allowed to have when using
	/// the certificate generated by this instance.
	/// </summary>
	public ICollection<IPAddress> AlternativeIpNames { get; set; } = new HashSet<IPAddress>();

	public HttpsCertificate Build()
	{
		var alternativeNameBuilder = new SubjectAlternativeNameBuilder();
		foreach (var ipAddress in AlternativeIpNames.Distinct())
		{
			alternativeNameBuilder.AddIpAddress(ipAddress);
		}
		foreach (var dnsName in AlternativeDnsNames.Distinct())
		{
			alternativeNameBuilder.AddDnsName(dnsName);
		}
		var alternativeNameExtension = alternativeNameBuilder.Build(true);
		var keyUsageExtension = new X509KeyUsageExtension(KeyUsageFlags, true);
		var basicConstraintsExtension = new X509BasicConstraintsExtension(true, false, 0, true);

		ECCurve secp256r1OidCurve = ECCurve.CreateFromValue("1.2.840.10045.3.1.7");
		var ecdsa = ECDsa.Create(secp256r1OidCurve);
		var certificateRequest = new CertificateRequest($"CN={CommonName}", ecdsa,
			HashAlgorithmName);

		certificateRequest.CertificateExtensions.Add(keyUsageExtension);
		certificateRequest.CertificateExtensions.Add(alternativeNameExtension);
		certificateRequest.CertificateExtensions.Add(basicConstraintsExtension);

		var certificate = certificateRequest.CreateSelfSigned(ValidNotBefore, ValidNotAfter);

		return new HttpsCertificate(certificate);
	}

	public static HttpsCertificateBuilder CreateForLocalMachine(TimeSpan validFor,
		bool supportIpv6)
	{
		var builder = new HttpsCertificateBuilder()
		{
			CommonName = Environment.MachineName,
			ValidNotBefore = DateTime.UtcNow.AddDays(-1),
			ValidNotAfter = DateTime.UtcNow.AddDays(1).Add(validFor)
		};

		var localIps = GetCurrentMachineIpAddresses(!supportIpv6, true);
		var localHostNames = GetCurrentMachineHostnames();

		foreach (var localIp in localIps)
		{
			builder.AlternativeIpNames.Add(localIp);
		}

		foreach (var localHostName in localHostNames)
		{
			builder.AlternativeDnsNames.Add(localHostName);
		}

		return builder;
	}

	public static IPAddress[] GetCurrentMachineIpAddresses(bool ipv4only, bool connectedOnly)
	{
		return NetworkInterface.GetAllNetworkInterfaces()
			.Where(i => i.OperationalStatus == OperationalStatus.Up || !connectedOnly)
			.SelectMany(i => i.GetIPProperties().UnicastAddresses)
			.Select(i => i.Address)
			.Where(i => i.AddressFamily == AddressFamily.InterNetwork || !ipv4only)
			.Distinct()
			.ToArray();
	}

	public static string[] GetCurrentMachineHostnames()
	{
		return (new string[] { Dns.GetHostName(), Environment.MachineName, "localhost" })
			.Where(a => a != null && a.Length > 0)
			.Distinct()
			.ToArray();
	}
}
